### 重写文法

* 目的：消除左递归

```shell
CompUnit -> {Decl} {FuncDef} MainFuncDef
	
1 decl part
    Decl -> ConstDecl | VarDecl
    BType ->  'int'
    
    ConstDecl ->  'const' BType ConstDef { ',' ConstDef } ';'
    ConstDef -> Ident { '[' ConstExp ']' } '=' ConstInitVal
    ConstInitVal -> ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}'	*
	ConstExp -> AddExp # 但是要求Ident为常量!

    VarDecl -> BType VarDef { ',' VarDef } ';'
    VarDef -> Ident { '[' ConstExp ']' } ['=' InitVal]
    InitVal ->  Exp | '{' [ InitVal { ',' InitVal } ] '}'

2 func part
    FuncDef -> FuncType Ident '(' [FuncFParams] ')' Block
    MainFuncDef ->  'int' 'main' '(' ')' Block
    FuncType -> 'void' | 'int'
    FuncFParams -> FuncFParam { ',' FuncFParam }
    FuncFParam -> BType Ident ['[' ']' { '[' ConstExp ']' }]
    
3 blk and stmt
	Block -> '{' { BlockItem } '}'
	BlockItem -> Decl | Stmt
	Stmt ->  LVal '=' Exp ';'
			| Block
			| 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
			| 'while' '(' Cond ')' Stmt 
			| 'break' ';' 
			| 'continue' ';' 
			| 'return' [Exp] ';' 
			| LVal '=' 'getint''('')'';' 
			| 'printf''('FormatString{','Exp}')'';' 
			| [Exp] ';'
	
4 exp part
	Exp -> AddExp # ("SysY 表达式是int 型表达式"是什么意思)
	Cond -> LOrExp
	LVal -> Ident {'[' Exp ']'}
	Number -> IntConst
	PrimaryExp -> '(' Exp ')' | LVal | Number
	UnaryExp -> {UnaryOp} (PrimaryExp | Ident '(' [FuncRParams] ')')
	UnaryOp -> '+' | '-' | '!'
	FuncRParams -> Exp { ',' Exp }
	
	MulExp -> UnaryExp {('*' | '/' | '%') UnaryExp}
	AddExp -> MulExp {('+' | '-') MulExp}
	RelExp -> AddExp {('<' | '>' | '<=' | '>=') AddExp}
	EqExp -> RelExp {('==' | '!=') RelExp}
	LAndExp -> EqExp {'&&' EqExp}
	LOrExp -> LAndExp {'||' LAndExp}
	
	
# IntConst 替换 Number
# LOrExp 替换 Cond
# AddExp 替换 Exp
# '+' | '-' | '!' 替换 UnaryOp

```

### 额外处理

#### 区分`Decl, FuncDef, MainFuncDef`

```shell
ConstDecl: 'const' BType Ident
VarDecl: Btype Ident # 之后可能是 , ; [
FuncDef: FuncType Ident '('
MainFuncDef: 'int' 'main' '(' ')' Block
```

#### 区分 `Decl, Stmt`

```shell
ConstDecl: 'const' BType Ident
VarDecl: Btype Ident # 之后可能是 , ; [
Stmt: Ident | ';' | 'if' | 'while' | 'break' | 'return' | 'printf'
	Exp: '+' | '-' | '!' | '(' | Ident | Number
	LVal: Ident
	Block: '{'
```

#### 区分`PrimaryExp, Ident '(' [FuncRParams] ')'`

```shell
LVal: Ident {'[' Exp ']'}
	: Ident '(' 
	# 应该没有语法成分是以'('开头的吧。。。

```

#### Stmt中区分`Exp ';' , LVal '='`

对于赋值语句和表达式语句，识别方法如下：从当前位置向后找，判断先遇到分号还是先遇到赋值符号(‘=’)。如果先遇到赋值符号，则说明是赋值语句，否则是表达式语句。



#### 处理`AddExp`等各种表达式时

需要手动添加`<xxxExp>`输出，因为此处修改了文法，但仍然需要按照此前文法输出各模块。

```shell
# 原文法
MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
```



### 小问题

变量声明/常量声明：数组长度可以为0，存在`a[3][0]={{},{},{}}`的情形。

以下样例是否合法？

```
int a[1][2] = {1,2};
int b[2][2] = {{1,2}, {}};
int c[1][1] = 1;
```

output时候记得`flush()`!